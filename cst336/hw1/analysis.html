<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Binary Analysis Project – Binary Analysis & Symbolic Execution</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&display=swap" rel="stylesheet">
    <link href="css/styles.css" rel="stylesheet">
  </head>

  <body>
    <header>
      <h1>Binary Analysis Desktop Application</h1>
    </header>

    <nav>
      <a href="index.html">Overview</a>
      <a href="analysis.html" class="active">Binary Analysis</a>
      <a href="design.html">Design & Wireframes</a>
      <a href="stack.html">Tech Stack</a>
    </nav>

    <section>
      <pre>
        load target → create symbolic state → explore paths (with limits) → summarize results → review in UI
      </pre>
    </section>

    <main>
      <div class="hero-text">
        <h2>What is <a href="https://www.blackduck.com/glossary/what-is-binary-code-binary-analysis.html" target="_blank" rel="noopener noreferrer">Binary Analysis</a>?</h2>
        <p>
          Binary analysis studies compiled programs (no source code required) to understand how they behave: what code runs, what inputs steer execution, and where bugs might live. 
          Tools emulate instructions, track memory/registers, and reason about paths to surface issues like buffer overflows or use-after-free. This is useful for reverse engineering, red-teaming, and vulnerability research.
        </p>
        <h2>What is <a href="https://docs.angr.io/en/latest/core-concepts/symbolic.html" target="_blank" rel="noopener noreferrer">symbolic execution</a>?</h2>
        <p>
          Symbolic execution runs a program with symbolic inputs instead of concrete values. When the program branches on a symbolic value, the engine can follow both sides, recording the logical condition (constraint) that makes each path possible. Solving those constraints gives test inputs that reproduce each path—including bug-revealing ones. 
          It’s powerful, but it is important to manage path explosion (the number of paths can blow up) with strategies and limits.
        </p>
        <p>
            <strong>Consider this simple program:</strong><pre>const char* check_value(int x) {
    if (x > 5) {
        return "Greater";
    } else {
        return "Lesser or Equal";
    }
}

    Path 1: X > 5 leading to the result "Greater"
    Path 2: X &le; 5 leading to the result "Lesser or Equal"
    Constraints for both paths are generated and solved to understand all possible behaviors of the program.</pre>
        
        <h2>What is <a href="https://docs.angr.io/" target="_blank" rel="noopener noreferrer">angr</a>?</h2>
        <p>
          angr is a Python framework for binary analysis. 
          It mixes static and dynamic/symbolic techniques and gives you high-level APIs to load a binary, create program states, and explore many paths at once using a SimulationManager
        </p>
      </div>
    </main>
    
    <section>
        <h5>Symbolic execution with angr: drive execution to the "Greater" branch</h5>
      <pre>

import angr
import claripy

proj  = angr.Project("./check_value", auto_load_libs=False)

# Make argv[1] symbolic (a 32-bit integer)
x = claripy.BVS("x", 32)
state = proj.factory.entry_state(args=["./check_value", x])

# Explore until the program prints "Greater", avoid the "Lesser or Equal" branch
simgr = proj.factory.simgr(state)
simgr.explore(
    find=lambda s: b"Greater" in s.posix.dumps(1),
    avoid=lambda s: b"Lesser or Equal" in s.posix.dumps(1),
)

# Recover a concrete solution for x
if simgr.found:
    model = simgr.found[0].solver.eval(x, cast_to=int)
    print("x =", model)   # e.g., x = 8
      </pre>
    </section>

    <footer class="site-footer">
      <hr>
      CST336 Internet Programming. 2025&copy; Waltman
      <img class="footer-logo" src="img/csumb_logo.png" alt="CSUMB logo" width="280">
    </footer>
  </body>
</html>